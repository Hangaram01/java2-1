#202330131 한가람 
# Markdown 문법 정리 
# h1 
## h2
### h3
#### h4
##### h5
###### h6
일반 글씨는 h4정도 크기 <br><br>
개행(newline)을 할 떄느 스페이스 2개

*이탤릭체*
**굵게**
***이탤릭+ 굵게***

# 리스트
1. 첫 번째
2. 두 번째
3. 세 번째

* 첫 번째 
   * 두 번째
     - 세 번째

# 코드블럭 
```java
public class main{
 public static void main(string[] args) {
    system.out.println("Hello World");
 }
}
```

# 링크 
[구글링크] (https://google.com)
[폰드 관련 명령](#markdown-문법-정리)
![상대 경로](./ac15fba50b4b34ca4ea08627a47e9dda.jpg)
![절대 경로](https://rgo4.com/files/attach/images/2681740/368/917/022/ac15fba50b4b34ca4ea08627a47e9dda.jpg)
# 라인


# 3월 15일 내용 정리
컴퓨터는 어떤 소프트웨어 혹은 프로그램도 처리 할 수 있는 만는 기계이다.
중앙 처리 장치(CPU)와 메모리, 키보드, 마우스,  스크린과 같은 입출력 장치를 갖추고,  어떤 종류의 소프트웨어든 처리한다.

프로그래밍 언어는 컴퓨터가 실핼할 프로그램을 작성하기 위한 언어이다.
고급 언어는 크게 절차 지향 언어와 객체 지향 언어로 나눌 수 있으며 자바는 객체 지향 언어이다.

플랫폼 중송석은 C/C++프로그램은 실행하고자 하는 각 플랫폼을 대상으로 소스 코드를 수정하거나, 각 플랫폼에서 따로 컴파일 하여 플랫폼에 맞는 기계어 프로그램을 생성하여야 하는 것이다.

JDK는 (Java Development Kit)는 자바를 개발 하기 위한 상업용 소프트웨어이다.

JRE(Java Runtime Environment)는 자바 으용프로그램이 실행될 때 필요한 소프트웨어이다.

자자 클래스의 이름과 자바 소스 파일의 이름은 동일해야 한다. 그래야만 클래스의 바이트 코드가 담긴 클래스 파일을 쉽게 찾을 수 있기 때문이다. 자바 프로그램은 클래스의 선언으로 시작하며, 변수나 메소드는 클래스 내에서만 선언이 가능하다. 자바 프로그램의 실행은 main()소드부터 시작한다.

자바의 특징은 플랫폼의 독립성, 객체 지향, 클래스로 캡슐화, 소스와 클래스 파일, 실행코드 배포, 패키지, 멀티 스레드, 가비지 컬렉션, 실시간 응용 시스템에 부적합, 자바 프로그램은 안전하다, 프로그램 작성이 쉽다, 실핼 속도를 개선하기 위해 JIT 컴파일러가 사용된다.

# 3월 22일 내용 정리
자바 프로그램의 구성 요소는 클래스 만들기,  주석문, main() 메소드, 메소드, 메소드 호출, 변수 선언, 문장, 화면 출력이 있다.

식별자란 클래스, 변수, 상수, 메소드에 붙는 이름을 말한다.

데이터 타입이란 자바에서 다룰 수 있는 데이터의 종류를 말한다. 종류로는 9개의 데이터 타입이 있다
-기본 타입(8개): boolean, char, byte, short, int, long, float, duoble
-레퍼런스 타입(1개): 배열에 대한 레퍼런스, 클래스에 대한 레퍼런스, 인터페이스에 대한 레퍼런스

자바의 연산자는 C/C++와 거의 동일하며, 산술, 증감, 비교, 논리, 직간, 조건, 대입연산자를 제공한다.

자바의 조건문에는 단순if문, if-else문, 중첩 if-else문, switch문이 있다.

case문의 값으로는 정수 리터럴, 문자 리터러르 문자열 리터럴만 사용 할 수 있으며, 변수나 식은 이용 할 수 없다.

# 3월 29일 내용 정리
자바의 반복문은 for문, while문, do-while-문 3가지가 있다.
반복문내의 다시 반복문을 사용할 수가 있는데 이것을 중첩 반복이라고 한다.

continue문은 반복문을 빠져나가지 않고 다음 반복문으로 진행된다.
break문은 하나의 반복문을 빠져나갈 때 사용된다.

배열은 같은 종류의 데이터가 순차적으로 연결되어 저장된 자료 구조이다.

배열을 만드는 과정은 2가지의 과정으로 이루어진다 배열 메모리를 가리키는 레퍼런스 값을 가질 변스에 대한 선언인 레퍼런스 변수의 선언과 배열 저장 공간을 확보하는 배열생성이다

배열의 크기는 배열의 객체의 length필드에 저장되어 있으며, 배열의 인덱스는 0부터 시작한다. 배열의 그 크기를 넘어서 접근하면 실행 중 오류가 발생한다.

for-each문은 배열의 각 원소를 순차적으로 접근하는 특별한 for문으로서, 정수 배열의 모든 원소를 출력하는 코드의 사례로 다음이 있다
int[] array = {1, 2, 3, 4};
for(int k : array) { System.out.println(k); }

예외는 싱행중에 오동작이나 결과에 악역향을 미치치 못한 요류이다.

자바 응용프로그램이 예외 처리 코드를 가지고 있지 않으면, 강제 종료된다.

예외가 잘샌할 가능성이 있는 코드는 try {} 블록으로 싸고, 예외가 발생할 때 처리 하는 코드는 catch() {} 블록으로 작성하고 예외가 발생하든 안하든 최종적으로 실행할 코드는 finally {} 블록으로 작성하고 finally {} 블록은 생략이 가능하다.
try 블록 내에서 예외가 발생하면 발생한 예외 타입과 일치하는 catch 블록으로 점프하고 일치하는 catch 블록이 없으면 강제 종료 된다.

# 4월 5일 내용 정리
객체 지향 언어에서는 실제 세상을 모델링 하여 객체, 객체 간의 상호 작용으로 나타내며 캡슐화, 상속, 다향성등 객체에 대한 3가지 특성을 갖는다.

클래스는 객체를 생성하기 위한 설계도 또는 틀이라고 볼 수 있으며, 객체는 설게도 또는 툴로 찍어낸 실체라고 볼 수 있다.

자바에서는 반드시 new연산자를 사용하여 객체를 생성한다.

생성자는 객체를 생성할 때만 호출되며 객체를 초기화 하기 위한 목적이다.

this()는 다른 생성자를 호출하는 문장이며, 생성자의 첫번째 코드로만 사용할 수 있다.

자바의 메소드 호출 시 기본 타입의 인자 전달 방식은 값에 의한 호출이다.
클래스 내에서 메소드의 이름은 같지만 인자의 개수와 타입아 서로 다른 여러 개의 메소드를 작성하는 것을 메소드 오버로딩이라고 부르고 이것은 다향성의 한 종류이다.

멤버의 접근자 지정자로는 private, protected, 디폴트, public가 있다.

static 멤버들은 클래스 당 하나만 생성되므로 클래스 멤버라고 부르며, 프로그램이 시작될 때 이미 생성되어 객체를 생성하지 않고도 사용 할 수 있다. 반면 non-static 멤버는 객체마다 생기기 때문에 인스턴스 멤버라고 부른다.

fina로 선언된 클래스는 더이상 상속되이 않으며, final로 선언된 메소드는 더 이상 오버라이딩이 될 수 없고, final로 선언된 필드는 상수로서, 실행중에 값을 변경 할 수 없다.

# 4월 12일 내용 정리
자바에서 상속은 부모 클래스의 필드와 메소드를 자식의 클래스에게 물려주는 것이다. 부모 클래스를 슈퍼 클래스, 자식 클래스를 서브 클래스라고 한다.

자바에서 상속을 선언할 때 expends 키워드를 사용한다.

슈퍼 클래스의 protected 멤버는 패키기 소속과 상관없이 서브 클래스에서 접근이 가능하며 동일한 패키기 내의 클래스에서도 접근이 가능하다.

만일 슈퍼 클래스의 생성자를 명시적으로 선택하지 않으면, 컴파일러느 슈퍼 클래스의 매개 변수 없는 기본 생성자를 선택한다.

서브 클래스 객체는 슈퍼 클래스 타입으로 자동 타입 변환이 가능하며 이를 업캐스팅이라고 하며, 다시 원래의 타입으로 강제 변환하는 것을 다운캐스팅이라고 한다.

instanceof 연산자의 결과값은 boolean 타입이며 개체가 어떤 클래스 타입인지 판별할 수 있다. 

메소드 오버라이딩은 슈퍼 클래스에 선언된 메소드를 서브 클래스에서 재정의하는 것이다.

호출된 메소드는 실행 시간에 찾아서 실행하는 것을 동적바인딩이라고 부르며, 오버라이딩된 메소드는 동적 바인딩 방식으로 호출되고 실행된다.

추상 메소드는 실행 코드 없이 원형만 선언된 미완성 메소드이며, 반드시 이름 앞에 abstract를 붙여 선언한다

인터페이스를 구현할 때는 interface 키워드를 사용하며, 인터페이스의 모든 추상 메소드를 구현하여야 한다.

# 4월 19일 내용 정리
추상 메소드 - abstract 키워드와 함께 선언되고, 코드는 작성되지 않은 메소드이다

추상 클래스 - abstract로 선언한 클래그로서 두가지의 경우가 있다.
- 추상 메소드를 최소한 한 개 이상 가지고 abstract로 선언된 클래스
- 추상 메소드가 없어도 abstract로 선언한 클래스

추상 클래스의 인스턴스를 생성 할 수 없다.
=> 추상 클래스 에는 실행 코드가 없는 미완성 상태인 추상 메소드가 있을 수 있기 때문이다.

JComponent p; //오류 없음. 추상 클래스 래퍼런스 선언
p = new JComponent(); //컴파일 오류. 추상 클래스의 인스턴스 생성 불가
shape obj = new Shape(); //컴파일 오류. 추상 클래스의 인스턴스 생성불가

추상 클래스의 상속
-추상 메소드를 가진 추상 클래스를 상속 받는 서브 클래스는 자동으로 추상 클래스가 된는 이유는 추상 메소드를 상속 받기 때문이다.

abstract class A { // 추상 클래스
   abstractpublis int add(int x, int y);  // 추상 메소드
   }
abstract class B extend A { // 추상 클래스. 추상 메소드 add()를 상속 받기 때문
   }

Wrapper에는 Byte, Short, Integer, Long, Chracter, float, Double, boolean이 있다.

String을 이영하여 문자열을 표현하고 문자열을 조작할 수 있고 한번 만들어진 String 객체의 문자열은 변경할 수 없다.

StringBuffer는 String 클래스와 달리 내부 버피를 가지고 있어, 문자열을 변경할 수 있다. 

# 5월 3일 내용 정리
컬렉션 : 요소라고 불리는 가변 개수의 객체들의 저장소
고정 크기의 배열다루는데 어려움 있다.

컬렉션 제네릭
제네릭 : 특정 타입만 다루지 않고, 여러 종류의 타입으로 변신할 수 있도록 클래스나 메소드를 일반화 시키는 기법
클래스나 인터페이스 이름에 <E>, <K>, <V>등 타입매개변수 포함

제네릭
JDK1.5부터 도입(2004년 기준)
C++의 템플릿과 동일

벡터 Vector<E>의 특성
<E>에 사용할 요소의 특정 타입으로 구체화

배열을 가변 크기로 다룰 수 있게 하는 컨테이너
-배열의 길이 제한 극복
-요소의 개수가 넘치면 자동으로 길이 조절

벡터 삽입 가능한것
-객체,null
-기본 타입값은 Wrapper객체로 만들어 저장

벡터 객체에 삽입
벡터의 맨뒤

JDK 1.5버전 이전
-기본 타입 데이터를 Wrapper 객체로 만들어 삽입
-컥렉션으로부터 요소를 얻어올 때 Wrapper클래스 캐스팅 필요

JDK 1.5버전 이후
-자동 박싱/언박싱이 작동하여 기본 타입 값 삽입 가능

Java 7이후
-컴파일러 타입 추론 기능 추가
<>(다이아몬드 연산자)에 타입 매개변수 생략

Java 10 이후
-Var 키워드 도입, 컴파일러의 지역 변수 타입 추론 기능

 키(Key)와 값(Value)의 쌍으로 구성되는 요소를 다루는 컬렉션
 K: 키로 사용할 요소의 타입
 V: 값으로 사용할 요소의 타입
 키와 값이 한 쌍으로 삽입
 '값'을 겁색하기 위해서느 반드시 '키' 이용

제네릭 클래스 작성
클래스 이름 옆에 일반화된 타입 매개 변수 추가

제네릭 객체 생성 및 활용
제네릭 타입에 구체적인 타입을 지정해 객체 생성하는 것 구체화라고 함

GUI 응용 프로그램
GUI: 사용자가 편리하게 입출력 할 수 있도록 그래픽으로 화면을 구성하고,  마우스나 키보드로 입력을 받을 수 있도록 지원하는 사용자 인터페이스

자바 언어에서 GUI 응용프로그램 작성
-AWT와 Swing 패키지에 강력한 GUI 컴포넌트 제공
-쉬운GUI 프로그래밍

AWT와 Swing패키지
AWT 패키지
-자바가 처음 나왔을 때부터 배포된 GUI 패키지, 최근에는 거의 사용하지 않음
-AWT 컴포넌트는 중량 컴포넌트

Swing 패키지
AWT 기술을 기반으로 각성된 자바 라이브러리
AWT 컴포넌트를 모두 스윙으로 재작성, AWT컴포넌트 이름앞 J자 덧붙임
순수 자바 언어로 구현
스윙 컴포넌트는 경량 컴포넌트(light weight component)
현재 자바의 GUI로 사용됨

컨테이너
-다른 컴포넌트를 포함할 수 있는 GUI 컴포넌트
-다른 컴테이너에 포함될 수 있다

컴포넌트
컴테이너에 포함되어야 화면에 출력될 수 있는 GUI 객체
다른 컴포넌트를 포함할 수 없는 순수 컴포넌트
모든 GUI 컴포넌트가 상속받는 클래스 : java.awt.component
스윙 컴포넌트가 상속받는 클래스 : java.swingJComponent

최상위 컴포넌트
- 다른 컨테이너에 포함되지 않고도 화면에 출력되어 독립적으로 전재 가능

스윙 GUI 프로그램을 만드는 과정
1.스윙 프레임 작선
2.main() 메소드 작성
3.프레임에 스윙 컴포넌트 붙이기

스윙 프레임 : 모든 스윙 컴포넌트 담는 최상위 컨테니어
JFrame 클래스를 상속받은 클래스 작성
프레임의 크기 반드시 지정:setSize() 호출
프레임을 화면에 출력하는 코드 반드시 지정

스윙 응용프로그램에서 main()의 기능 최소화 바람직
스윙 응용프로그램이 실행되는 시작점으로하면 좋다.

프레임에 컴포넌트 붙이기
-타이틀 달기
-메뉴 만들어 붙이기
-컨텐트팬에 컴포넌트 붙이기
*컨텐트팬의 변경

# 5월 17일 내용 정리
컨테이너의 배치관리자
컨테이너마다 하나의 배치관리자 존재

FlowLayout 배치관리자
컨포넌트가 삽입되는 순서대로 왼쪽에서 오른쪽으로 배치
배치할 공간이 없으면 아래로 내려와서 반복

BorderLayout 배치 관리자
컨테이너의 공간을 동, 서, 남, 북, 중앙의 5개 영역으로 나눔
5개의 영역중 응용프로그램에서 지정한 영역에 컨포넌트 배치

GiridLayout 배치관리자
컨테이너를 프로그램에서 설정한 동일한 크기의 2차원 격차로 나눔


CardLayout
컨테이너의 공간에 카드를 쌓아놓은듯이 컴포넌트 배치

컨티이너의 디폴트 배치관리자
컨테이너 생성시 자동으로 생성되는 배치관리자

컨테이너의 새로운 배치관리자 설정
setLayout(LayoutManager lm) 메소드 호출
lm을 새로운 배치관리자로 설정

JPanel 컨테이너에 BorderLayout 배치관리자를 성정하는 예
'''java
   JPanel p = new JPanel();
   p.setLayout(new BorderLayout()); // JPanel에 BorderLayout설정
'''

컨텐트팬의 배치관리자를 FlowerLayout 배치관리자를 성성하는 예
Container c = frame.gerContentPane(); //프레임의 컨텐트팬 알아내기
c.setLayout(mre FlowerLayout()); //컨텐트팬에 FlowerLayout 설정

오류
c.setLayout(FlowerLayout); //오류

배치방법
컴포넌트를 컨테이너 내에 왼쪽에서 오른쪽으로 배치
다시 위에서 아래로 순서 배치

생성자
FlowLayout()
FlowLayout(int align, int hGap, int vGap)
align: 컴포넌트를 정렬하는 방법 지장, 왼쪽 정렬(FlowLayout.LEFT), 오른쪽(FlowLayou.RIGHT), 중앙 정렬(FlowLayoutCENTER(디폴트))

hGap: 좌우 두 컴포넌트 사이의 수평 간격, 픽셀단위, 디폴트 5
vGap: 상하 두 컴포넌트 사이의 수평 간격, 픽셀단위, 디폴트 5

배치방법
컨테이너 공간을 5 구역으로 분할, 배치
동,서,남,북,중앙
배치방법
add(Component comp, int index)

생성자
BorderLayout() 
BorderLayout(int hGap, int vGap)
hGap: 좌우 두 컴포넌트 사이의 수평 간격, 픽셀단위(디폴트 : 0)
vGap: 상하 두 컴포넌트 사이의 수평 간격, 픽셀단위(디폴트 : 0)

add() 메소드

배치방법
컨테이너 공간을 동일한 사각형 격자(그리드)로 분할하고 각 셀에 컴포넌트 하나씩 배치
-생성자에 행수와 열수 지정
-셀에 왼쪽에서 오른쪽으로, 다시 위에서 아래 순서대로 배치

생성자
GridLayout()
GridLayout(int rows, int cols)
GridLayout(int rows, int cols, int hGap, int vGap)
-rows: 격자의 행수(디폴트 : 1)
-cols:격자의 열수(디폴트 : 1)
-hGap:좌우 두 컴포넌트 사이의 수평 간격, 픽셀단위(디폴트 : 0)
-vGap:상하 두 컴포넌트 사이의 수평 간격, 픽셀단위(디폴트 : 0)
-rows x cols만큼의 셀을 가진 격자로 컨테이너 공간을 분할, 배치

배치 =관리자가 없는 컨테이너가 필요한 경우
응용프로그램에서 직접 컴포넌트의 크기와 위치를 결정하고자 하는 경우
1. 컴포넌트의 크기나 위치를 개발자 임의로 결정하고자하는 경우
2. 게임 프로그램과 같이 시간이나 마우스/키보드의 입력에 따라 컴포넌트들이 위치와 크기가 수시로 변하는 경우
3. 여러 컴포넌튿르이 서로 겹쳐 출력하고자 하는 경우

배치관리자가 없는 컨테이너에 컴포넌트 삽입할 때
프로그램에서 컴포넌트의 절대 크기와 

# 5월 24일 내용 정리
이벤트 기간 프로그래밍
이벤트의 발생에 의해 프로그램 흐름이 결정되는 방식
-이밴트가 발생하면 이벤트를 처리하는 루틴(이벤트 리스너)실행
-실행코드는 이벤트의 발생에 의해 전적으로 결정

반대되는 개념: 배치 실행
프로그램의 개발자가 프로그램의 흐름을 결정하는 방식

이벤트 종류
사용자의 입력: 마으스 드래그, 마우스 클릭, 키보드 누름 등
센서로부터의 입력, 네트워크로부터 데이-터 송수신
다른 응용프로그램이나 다른 스레드로부터의 메시지

이벤트 기반 응용 프로그램의 구조
-각 이벤트마다 처리하는 리스너 코드 보유

이벤트가 처리되는 과정
이벤트 발생
예: 마우스의 움직임 혹은 키보드입력

이벤트 객체 생성
현재 발생한 이벤트에 대한 정보를 가진 객체

응용프로그램에 작성된 이벤트 리스너 찾기
이벤트 리스너 실행
-리스너에 이벤트 객체 전달
-리스너 코드 실행

이벤트 객체 
발생한 이벤트에 관한 정보를 가진객체
이벤트 리스너에 전달됨
-이벤트리스너 코드가 발생한 이벤트에 대한 상황을 파악할 수 있게 함

이벤트객체가 포함하는 정보
+이벤트 종류와 이벤트 소스
+이벤트가 발생한 화면 좌표 및 컴포넌트 내 좌표
+이벤트가 발생한 튼이나 메뉴 아이템의 문자열
+클릭된 마으스 버튼 번호 및 마우스의 클릭 횟수
+키의 코드값과 문자 값
+체크박스, 라디오버튼 등과 같은 컴포넌트에 이벤트가 발생하였다면 체크상태

이벤트 소스를 알아내는 메소드
object getSource()
-발생한 이벤트의 소스 컴포넌트 리턴
-object 타입으로 리턴하므로 캐스팅하여 사용
-모든 이벤트 객체에 대해 적용

이벤트 리스너
이벤트를 처리하는 자바 프로그램 코드, 클래스로 작성

자바는 다양한 리스너 인터페이스 제공
예)ActionListener 인터페이스-버튼 클릭 이벤트를 초리하기 위한 인터페이스
interface ActionListener{// 아래 메소드를 개발자가 구현해야함
   public viod actionPerformed(ActionEvent e); /Action 이벤트발생시 호출됨}

예)MouseListener 인터페이스-마으스 조작에 따른 이벤트 처리하기 위한 인터페이스
interface MouseListener{//아래 5개 메소드를 개발자가 구현해야함
   public void mousePressed(MouseEvent e);
   public void mouseReleased(MouseEvent e);
   public void mousePressedClicked(MouseEvent e);
   public void mouseEntered(MouseEvent e);
   public void mouseExited(MouseEvent e);}

사용자의 이벤트 리스너 작성
+자바의 리스너 인터페이스를 상속받아 구현
+리스너 인터페이스의 보든 추상 메소드 구현

이벤트와 이벤트 리스오 선택
+버튼 클릭을 처리하고자 하는 경우
- 이벤트:Action 이벤트, 이벤트 리스너:ActionListener

이벤트 리스너 등록
+이벤트를 받아 처리하고자 하는 컴포넌트에 이벤트 리스너 등록
+component.addXXXListener(listener)

이벤트 리스너 작성방법
3가지 방법
+돌립 클래스로 작성
-이벤트 리스너를 완전한 클래스로 작성
-이벤트 리스너를 여러 곳에서 사용할 때 적합

+내부 클래스로 작정
-클래스 안에 멤버처럼 클래스 작성
-이벤트 리스노를 특정 클래스에서만 사용할 때 적합

+익명 클래스로 작성
-클래스의 이름 없이 간단히 리스너 작성
-클래스 조차 만들 필요 없이 리스너 코드가 간단한 경우에 적합

익명 클래스: 이름 없는 클래스
(클래스 선언 + 인스턴스 생성)을 한번에 달성

 간단한 리스너 경우 익명 클래스 사용 추천
 메소드 개수가 1,2개인 리스너(ActionListener, interListener)에 대해 주로 사용